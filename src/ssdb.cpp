#include <stdlib.h>
#include "ssdb.h"
#include "slave.h"
#include "leveldb/iterator.h"
#include "leveldb/cache.h"

SSDB::SSDB(){
	db = NULL;
	meta_db = NULL;
	slave = NULL;
	replication = NULL;
	options.create_if_missing = true;
	iterate_options.fill_cache = false;
}

SSDB::~SSDB(){
	if(db){
		delete db;
	}
	if(slave){
		delete slave;
	}
	if(replication){
		delete replication;
	}
	if(options.block_cache){
		delete options.block_cache;
	}
	if(meta_db){
		delete meta_db;
	}
}

SSDB* SSDB::open(const Config &conf, const std::string &base_dir){
	std::string main_db_path = base_dir + "/data";
	std::string meta_db_path = base_dir + "/meta";
	std::string role = conf.get_str("replication.role");
	int cache_size = conf.get_num("leveldb.cache_size");
	int write_buffer_size = conf.get_num("leveldb.write_buffer_size");
	int block_size = conf.get_num("leveldb.block_size");

	if(cache_size <= 0){
		cache_size = 8;
	}
	if(write_buffer_size <= 0){
		write_buffer_size = 4;
	}
	if(block_size <= 0){
		block_size = 4;
	}
	// work as master if not implicitly configured as slave
	role = role == "slave"? "slave" : "master";

	log_info("role       : %s", role.c_str());
	log_info("main_db    : %s", main_db_path.c_str());
	log_info("meta_db    : %s", meta_db_path.c_str());
	log_info("cache_size : %d MB", cache_size);
	log_info("block_size : %d KB", block_size);
	log_info("write_buffer_size : %d MB", write_buffer_size);

	leveldb::Status status;
	SSDB *ssdb = new SSDB();
	if(cache_size > 0){
		ssdb->options.block_cache = leveldb::NewLRUCache(cache_size * 1048576);
	}

	leveldb::Options options;
	options.create_if_missing = true;
	options.write_buffer_size = write_buffer_size * 1024 * 1024;
	options.block_size = 4 * 1024;
	status = leveldb::DB::Open(options, meta_db_path, &ssdb->meta_db);
	if(!status.ok()){
		goto err;
	}

	if(role == "master"){
		MyReplication *repl = new MyReplication(ssdb->meta_db);

		ssdb->replication = repl;
		ssdb->options.replication = repl;
	}

	status = leveldb::DB::Open(ssdb->options, main_db_path, &ssdb->db);
	if(!status.ok()){
		log_error("open main_db failed");
		goto err;
	}

	// a master can also be a slave
	{ // slave
		std::string ip;
		int port;
		ip = conf.get_str("replication.slaveof.ip");
		port = conf.get_num("replication.slaveof.port");
		if(ip != ""){
			ssdb->slave = new Slave(ssdb, ssdb->meta_db, ip.c_str(), port);
			ssdb->slave->start();
			log_info("slaveof: %s:%d", ip.c_str(), port);
		}
	}

	return ssdb;
err:
	if(ssdb){
		delete ssdb;
	}
	return NULL;
}

Iterator* SSDB::iterator(const std::string &start, const std::string &end, int limit) const{
	leveldb::Iterator *it;
	it = db->NewIterator(iterate_options);
	it->Seek(start);
	// TODO: if start > end: reverse iterate
	if(it->Valid() && it->key() == start){
		it->Next();
	}
	return new Iterator(it, end, limit);
}


/* raw operates */

int SSDB::raw_set(const Bytes &key, const Bytes &val) const{
	leveldb::Status s = db->Put(write_options, key.Slice(), val.Slice());
	if(!s.ok()){
		log_error("set error: %s", s.ToString().c_str());
		return -1;
	}
	return 1;
}

int SSDB::raw_get(const Bytes &key, std::string *val) const{
	leveldb::ReadOptions opts;
	opts.fill_cache = false;
	leveldb::Status s = db->Get(opts, key.Slice(), val);
	if(s.IsNotFound()){
		return 0;
	}
	if(!s.ok()){
		log_error("get error: %s", s.ToString().c_str());
		return -1;
	}
	return 1;
}

int SSDB::raw_del(const Bytes &key) const{
	leveldb::Status s = db->Delete(write_options, key.Slice());
	if(!s.ok()){
		log_error("del error: %s", s.ToString().c_str());
		return -1;
	}
	return 1;
}
